/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM.MySQL;

use Runtime.lib;
use Runtime.CoreStruct;
use Runtime.ORM.Connection;
use Runtime.ORM.Cursor;
use Runtime.ORM.ORMProviderInterface;
use Runtime.ORM.QueryBuilder;
use Runtime.ORM.MySQL.Driver;


struct Provider extends CoreStruct implements ORMProviderInterface
{
	
	string host = "";
	int port = 3306;
	string username = "";
	string password = "";
	string db = "";
	string prefix = "";
	bool log_query = false;
	
	
	
	/**
	 * Returns providers hash
	 */
	pure string getHash(Provider p) =>
		p.hostname ~ "|" ~
		p.port ~ "|" ~
		p.username ~ "|" ~
		p.password ~ "|" ~
		p.db ~ "|" ~
		p.prefix
	;
	
	
	
	/**
	 * Execute query
	 */
	static fn execute(QueryBuilder q) =>
		async Cursor (Provider p) use (q)
		{
			fn escape = string (string item) => static::escape(item);
			
			/* Select query */
			if (q._kind == QueryBuilder::QUERY_SELECT)
			{
				string sql = "SELECT ";
				Map params = new Map();
				
				/* Add fields */
				if (q._fields != null) sql ~= rs::join(", ", q._fields);
				
				/* Add table name */
				string table_name = q._table_name;
				sql ~= " FROM " ~ escape(table_name);
				
				/* Add table alias */
				if (q._table_name_alias != "") sql ~= " AS " ~ q._table_name_alias;
				
				/* Add where */
				if (q._where != null)
				{
					Vector<string> where = new Vector();
					q._where.each
					(
						void (var value, string key) use (where, params, escape)
						{
							where.push(escape(key) ~ " = :" ~ key);
							params.set(key, value);
						}
					);
					string where_str = rs::join(" AND ", where);
					if (where_str != "") sql ~= " WHERE " ~ where_str;
				}
				
				/* Add order */
				if (q._order != null)
				{
					Collection order = q._order.map
					(
						string (Collection order) => order[0] ~ " " ~ order[1]
					);
					
					string order_str = rs::join(", ", order);
					if (order_str != "") sql ~= " ORDER BY " ~ order_str;
				}
				
				/* Add order */
				if (q._limit >= 0) sql ~= " LIMIT " ~ q._limit;
				if (q._start >= 0) sql ~= " OFFSET " ~ q._start;
				
				Cursor cursor = p -> await method query(sql, params.toDict());
				return cursor;
			}
			
			return null;
		}
	;
	
	
	
	/**
	 * Execute query
	 */
	static fn query(string sql, Dict params = null) =>
		async Cursor (Provider p) use (sql, params)
		{
			Driver d = @ -> method getDriver(classof Driver);
			
			/* Connect */
			Connection conn = await d.connect(p);
			
			/* Execute */
			Cursor cursor = await conn.prepare(sql);
			await cursor.execute(params, p.log_query);
			
			/* Return cursor */
			return cursor;
		}
	;
	
	
	
	/**
	 * Insert query
	 */
	static fn insert(string table_name, Dict insert) =>
		async Cursor (Provider p) use (table_name, insert)
		{
			Vector keys = new Vector();
			Vector values = new Vector();
			
			insert.each
			(
				void (string value, string key) use (keys, values)
				{
					keys.push("`" ~ key ~ "`");
					values.push(":" ~ key);
				}
			);
			
			string sql = "insert into " ~ table_name ~
				" (" ~ rs::join(", ", keys) ~ ") values (" ~ rs::join(", ", values) ~ ")"
			;
			
			Cursor cursor = p -> method query(sql, insert);
			cursor.setKind("insert");
			return cursor;
		}
	;
	
	
	
	/**
	 * Update query
	 */
	static fn update(string table_name, Dict where, Dict update) =>
		async Cursor (Provider p) use (table_name, where, update)
		{
			Map items = new Map();
			Vector v_set = new Vector();
			Vector v_where = new Vector();
			
			where.each
			(
				void (string value, string key) use (items, v_set, v_where)
				{
					v_where.push("`" ~ key ~ "` = :where_" ~ key);
					items.set("where_" ~ key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (items, v_set, v_where)
				{
					v_set.push("`" ~ key ~ "` = :update_" ~ key);
					items.set("update_" ~ key, value);
				}
			);
			
			string sql = "update " ~ table_name ~ " set " ~ rs::join(", ", v_set) ~
				" where " ~ rs::join(" and ", v_where)
			;
			
			Cursor cursor = p -> method query(sql, items);
			cursor.setKind("update");
			return cursor;
		}
	;
	
	
	
	/**
	 * Insert or update
	 */
	static fn insert_or_update(string table_name, Dict insert, Dict update) =>
		async void (Provider p) use (table_name, insert, update)
		{
			Vector ins_keys = new Vector();
			Vector ins_values = new Vector();
			Vector where_data = new Vector();
			Vector upd_data = new Vector();
			Map items = new Map();
			Map ins_items = new Map();
			Map upd_items = new Map();
			
			insert.each
			(
				void (string value, string key) use (ins_keys, ins_values, where_data, items, ins_items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					where_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
					ins_items.set(key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (ins_keys, ins_values, upd_data, items, upd_items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					upd_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
					upd_items.set(key, value);
				}
			);
			
			/* Find item */
			Cursor c = p
				-> method query
				(
					"select `id` from `" ~ table_name ~ "` where " ~ rs::join(" and ", where_data) ~ " limit 1",
					ins_items
				)
			;
			Dict row = c.fetch();
			c.close();
			
			/* Update */
			if (row)
			{
				p 
					-> method update(table_name, ins_items, upd_items)
					-> method end
				;
			}
			
			/* Insert */
			else
			{
				p
					-> method insert(table_name, items)
					-> method end
				;
			}
		}
	;
	
	
	
	/**
	 * Insert or update
	 */
	static fn insert_or_update_atom(string table_name, Dict insert, Dict update) =>
		async void (Provider p) use (table_name, insert, update)
		{
			Vector ins_keys = new Vector();
			Vector ins_values = new Vector();
			Vector upd_data = new Vector();
			Map items = new Map();
			
			insert.each
			(
				void (string value, string key) use (ins_keys, ins_values, items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					items.set(key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (ins_keys, ins_values, upd_data, items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					upd_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
				}
			);
			
			string sql = "insert into " ~ table_name ~
				" (" ~ rs::join(", ", ins_keys) ~ ")" ~
				" values (" ~ rs::join(", ", ins_values) ~ ")" ~
				(
					(upd_data.count() == 0) ? "" :
						" ON DUPLICATE KEY UPDATE " ~ rs::join(", ", upd_data)
				)
			;
			
			Cursor cursor = p -> method query(sql, items) -> method end;
		}
	;
	
	
	
	/**
	 * Escape
	 */
	pure string escape(string item) => "`" ~ item ~ "`";
	
}