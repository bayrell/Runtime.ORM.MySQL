/*!
 *  Bayrell Runtime Library
 *
 *  (c) Copyright 2020 "Ildar Bikmamatov" <support@bayrell.org>
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace Runtime.ORM.MySQL;

use Runtime.lib;
use Runtime.CoreStruct;
use Runtime.ORM.Cursor;
use Runtime.ORM.ProviderInterface;
use Runtime.ORM.MySQL.Driver;


struct Provider extends CoreStruct implements ProviderInterface
{
	
	string host = "";
	int port = 3306;
	string username = "";
	string password = "";
	string db = "";
	string prefix = "";
	bool log_query = false;
	
	
	/**
	 * Returns providers hash
	 */
	pure string getHash(Provider p) =>
		p.hostname ~ "|" ~
		p.port ~ "|" ~
		p.username ~ "|" ~
		p.password ~ "|" ~
		p.db ~ "|" ~
		p.prefix
	;
	
	
	
	/**
	 * Execute query
	 */
	static fn query(string sql, Dict params) =>
		async Cursor (Provider p) use (sql, params)
		{
			Driver d = @ -> method getDriver(classof Driver);
			Cursor cursor = await d.query(p, sql, params);
			return cursor;
		}
	;
	
	
	
	/**
	 * Insert query
	 */
	static fn insert(string table_name, Dict insert) =>
		async Cursor (Provider p) use (table_name, insert)
		{
			Vector keys = new Vector();
			Vector values = new Vector();
			
			insert.each
			(
				void (string value, string key) use (keys, values)
				{
					keys.push("`" ~ key ~ "`");
					values.push(":" ~ key);
				}
			);
			
			string sql = "insert into " ~ table_name ~
				" (" ~ rs::join(", ", keys) ~ ") values (" ~ rs::join(", ", values) ~ ")"
			;
			
			Cursor cursor = p -> method query(sql, insert);
			return cursor;
		}
	;
	
	
	
	/**
	 * Update query
	 */
	static fn update(string table_name, Dict where, Dict update) =>
		async Cursor (Provider p) use (table_name, where, update)
		{
			Map items = new Map();
			Vector v_set = new Vector();
			Vector v_where = new Vector();
			
			where.each
			(
				void (string value, string key) use (items, v_set, v_where)
				{
					v_where.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (items, v_set, v_where)
				{
					v_set.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
				}
			);
			
			string sql = "update " ~ table_name ~ " set " ~ rs::join(", ", v_set) ~
				" where " ~ rs::join(" and ", v_where)
			;
			
			Cursor cursor = p -> method query(sql, items);
			return cursor;
		}
	;
	
	
	
	/**
	 * Insert or update
	 */
	static fn insert_or_update(string table_name, Dict insert, Dict update) =>
		async void (Provider p) use (table_name, insert, update)
		{
			Vector ins_keys = new Vector();
			Vector ins_values = new Vector();
			Vector where_data = new Vector();
			Vector upd_data = new Vector();
			Map items = new Map();
			Map ins_items = new Map();
			Map upd_items = new Map();
			
			insert.each
			(
				void (string value, string key) use (ins_keys, ins_values, where_data, items, ins_items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					where_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
					ins_items.set(key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (ins_keys, ins_values, upd_data, items, upd_items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					upd_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
					upd_items.set(key, value);
				}
			);
			
			/* Find item */
			Cursor c = p
				/* -> lib::copy{ "log_query": true } */
				-> method query
				(
					"select `id` from `" ~ table_name ~ "` where " ~ rs::join(" and ", where_data) ~ " limit 1",
					ins_items
				)
			;
			Dict row = c.fetch();
			c.close();
			
			/* Update */
			if (row)
			{
				p 
					/* -> lib::copy{ "log_query": true } */
					-> method update
					(
						table_name,
						ins_items,
						upd_items
					)
					-> method end
				;
			}
			
			/* Insert */
			else
			{
				p
					/* -> lib::copy{ "log_query": true } */
					-> method insert
					(
						table_name,
						items
					)
					-> method end
				;
			}
		}
	;
	
	
	
	/**
	 * Insert or update
	 */
	static fn insert_or_update_atom(string table_name, Dict insert, Dict update) =>
		async void (Provider p) use (table_name, insert, update)
		{
			Vector ins_keys = new Vector();
			Vector ins_values = new Vector();
			Vector upd_data = new Vector();
			Map items = new Map();
			
			insert.each
			(
				void (string value, string key) use (ins_keys, ins_values, items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					items.set(key, value);
				}
			);
			
			update.each
			(
				void (string value, string key) use (ins_keys, ins_values, upd_data, items)
				{
					ins_keys.push("`" ~ key ~ "`");
					ins_values.push(":" ~ key);
					upd_data.push("`" ~ key ~ "` = :" ~ key);
					items.set(key, value);
				}
			);
			
			string sql = "insert into " ~ table_name ~
				" (" ~ rs::join(", ", ins_keys) ~ ")" ~
				" values (" ~ rs::join(", ", ins_values) ~ ")" ~
				(
					(upd_data.count() == 0) ? "" :
						" ON DUPLICATE KEY UPDATE " ~ rs::join(", ", upd_data)
				)
			;
			
			Cursor cursor = p -> method query(sql, items) -> method end;
		}
	;
	
}